# Quest 2. Basic control structures. Some problems with symbols.
### Полный код:

```c
#include <stdio.h>
#include <stdlib.h>

// Функция для кодирования символов в их ASCII-коды
void encode() {
    char ch;
    int isFirst = 1;

    while ((ch = getchar()) != '\n') {  // Считываем до символа новой строки
        if (ch == ' ') continue;  // Пропускаем пробелы между символами

        if (!isFirst) {
            printf(" ");
        }
        printf("%02d", (int)ch);  // Выводим ASCII-код символа в двухсимвольном формате
        isFirst = 0;
    }
    printf("\n");
}

// Функция для декодирования ASCII-кодов в символы
void decode() {
    char code[3];   // Массив для хранения двухсимвольной строки
    code[2] = '\0';  // Завершающий нулевой символ для двухсимвольной строки

    int firstOutput = 1;
    while (1) {
        if (scanf("%2s", code) != 1) {  // Если не удается прочитать данные, выходим
            break;
        }

        // Если введена пустая строка, выходим из цикла
        if (code[0] == '\0') {
            break;
        }

        // Преобразуем строку в число ASCII
        int asciiValue = (code[0] - '0') * 10 + (code[1] - '0');
        if (asciiValue < 0 || asciiValue > 127) {  // Проверка диапазона ASCII
            printf("n/a\n");
            return;
        }

        if (!firstOutput) {
            printf(" ");
        }

        printf("%c", (char)asciiValue);  // Преобразуем ASCII-код в символ и выводим
        firstOutput = 0;
    }
    printf("\n");
}

int main(int argc, char *argv[]) {
    if (argc != 2) {  // Проверка числа аргументов командной строки
        printf("n/a\n");
        return 1;
    }

    int mode = argv[1][0] - '0';  // Преобразуем первый символ аргумента в число
    if (mode == 0) {
        encode();  // Режим кодирования
    } else if (mode == 1) {
        decode();  // Режим декодирования
    } else {
        printf("n/a\n");
        return 1;
    }

    return 0;
}
```

### Объяснение каждой строки кода:

#### 1. Подключение библиотек:
```c
#include <stdio.h>
#include <stdlib.h>
```
- **`#include <stdio.h>`** — подключает стандартную библиотеку для работы с вводом и выводом. Это нужно для использования таких функций как `printf`, `scanf`, `getchar`.
- **`#include <stdlib.h>`** — подключает библиотеку для работы с общими функциями, например, `atoi` (преобразование строки в число), но в нашем коде она используется лишь для корректности.

#### 2. Функция `encode`:
```c
void encode() {
    char ch;
    int isFirst = 1;
```
- **`void encode()`** — определяет функцию, которая будет заниматься кодированием символов в ASCII.
- **`char ch`** — переменная для хранения каждого символа, который считывается с клавиатуры.
- **`int isFirst = 1`** — флаг, который используется для того, чтобы не ставить пробел перед первым символом.

```c
    while ((ch = getchar()) != '\n') {
        if (ch == ' ') continue;
```
- **`while ((ch = getchar()) != '\n')`** — цикл, который продолжается до тех пор, пока не будет введен символ новой строки (`\n`), то есть когда пользователь нажмет Enter.
- **`getchar()`** — считывает один символ с клавиатуры.
- **`if (ch == ' ') continue;`** — если введен пробел, программа пропускает этот символ и переходит к следующей итерации цикла.

```c
        if (!isFirst) {
            printf(" ");
        }
```
- **`if (!isFirst)`** — если это не первый символ, то перед ним нужно вывести пробел.
- **`printf(" ");`** — печатает пробел, чтобы разделить коды символов.

```c
        printf("%02d", (int)ch);
        isFirst = 0;
    }
    printf("\n");
}
```
- **`printf("%02d", (int)ch);`** — выводит ASCII-код символа в виде двухзначного числа (если код однозначный, перед числом будет стоять ноль). Функция `(int)ch` преобразует символ в его ASCII-код.
- **`isFirst = 0;`** — устанавливает флаг `isFirst` в 0, чтобы на последующих итерациях перед кодом символа выводился пробел.
- **`printf("\n");`** — выводит символ новой строки после завершения кодирования.

#### 3. Функция `decode`:
```c
void decode() {
    char code[3];   // Массив для хранения двухсимвольной строки
    code[2] = '\0';  // Завершающий нулевой символ для двухсимвольной строки
```
- **`char code[3];`** — массив для хранения двухсимвольной строки (например, для кода `72` для символа 'H').
- **`code[2] = '\0';`** — ставим завершающий нулевой символ в конце массива, чтобы строка могла правильно обрабатываться.

```c
    int firstOutput = 1;
    while (1) {
        if (scanf("%2s", code) != 1) {
            break;
        }
```
- **`int firstOutput = 1;`** — флаг для того, чтобы перед первым символом не ставился пробел.
- **`while (1)`** — бесконечный цикл, который будет продолжаться до тех пор, пока не будет прочитано все.
- **`scanf("%2s", code)`** — считывает два символа, представляющих ASCII-код символа.
- **`if (scanf("%2s", code) != 1) { break; }`** — если не удается прочитать два символа (например, из-за конца ввода), цикл прерывается.

```c
        if (code[0] == '\0') {
            break;
        }
```
- **`if (code[0] == '\0') { break; }`** — если считывается пустая строка (пользователь нажал Enter, не введя коды), программа завершает декодирование.

```c
        int asciiValue = (code[0] - '0') * 10 + (code[1] - '0');
        if (asciiValue < 0 || asciiValue > 127) {
            printf("n/a\n");
            return;
        }
```
- **`int asciiValue = (code[0] - '0') * 10 + (code[1] - '0');`** — преобразует два символа из строки `code` в одно число. Например, если `code` равно `"72"`, то результат будет 72 (ASCII код символа 'H').
- **`if (asciiValue < 0 || asciiValue > 127)`** — проверка, чтобы ASCII-код был в пределах допустимого диапазона (от 0 до 127).
- **`printf("n/a\n"); return;`** — если код вне допустимого диапазона, выводится "n/a" и функция завершает выполнение.

```c
        if (!firstOutput) {
            printf(" ");
        }
        printf("%c", (char)asciiValue);  // Преобразуем ASCII-код в символ и выводим
        firstOutput = 0;
    }
    printf("\n");
}
```
- **`if (!firstOutput) { printf(" "); }`** — если это не первый вывод, перед символом выводится пробел.
- **`printf("%c", (char)asciiValue);`** — преобразует числовой ASCII-код в символ и выводит его.
- **`firstOutput = 0;`** — флаг, чтобы между символами ставился пробел только после первого.

#### 4. Функция `main`:
```c
int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("n/a\n");
        return 1;
    }
```
- **`if (argc != 2)`** — проверяет, что программа была вызвана с одним аргументом командной строки (режим работы: `0` или `1`).
- **`printf("n/a\n"); return 1;`** — если аргументов не два, выводится "n/a" и программа завершает выполнение.

```c
    int mode = argv[1][0] - '0';  // Преобразуем первый символ аргумента в

 число
    if (mode == 0) {
        encode();  // Режим кодирования
    } else if (mode == 1) {
        decode();  // Режим декодирования
    } else {
        printf("n/a\n");
        return 1;
    }
```
- **`int mode = argv[1][0] - '0';`** — преобразует строку аргумента в число (например, '0' становится 0, '1' становится 1).
- **`if (mode == 0)`** — если аргумент равен 0, вызывается функция кодирования.
- **`else if (mode == 1)`** — если аргумент равен 1, вызывается функция декодирования.
- **`else { printf("n/a\n"); return 1; }`** — если аргумент не равен ни 0, ни 1, выводится "n/a".

```c
    return 0;
}
```
- Завершающая строка в функции `main`, возвращающая код 0, что означает успешное завершение программы.

### Итог:
Этот код выполняет кодирование и декодирование с использованием ASCII-кодов, с разделением вывода пробелами между символами. В режиме кодирования программа выводит ASCII-коды символов, а в режиме декодирования — символы, соответствующие этим кодам.

# Quest 4
### Заголовочные файлы и константы

```c
#include <stdio.h>
#include <math.h>

#define PI 3.14159265358979323846
```

1. **`#include <stdio.h>`** — подключение библиотеки для ввода/вывода. Эта библиотека необходима для работы с функциями `printf`, `fprintf` и другими функциями ввода/вывода.
   
2. **`#include <math.h>`** — подключение математической библиотеки, которая предоставляет стандартные математические функции, такие как `sqrt` (квадратный корень), которые используются в коде.

3. **`#define PI 3.14159265358979323846`** — определение константы для числа \( \pi \), которое будет использоваться в вычислениях.

### Функции для вычислений

#### Функция Верзьера Аньези

```c
double verzier(double x) {
    if (x >= -1 && x <= 1) {
        return 1.0 / sqrt(1 - x * x);
    } else {
        return -1;  // Функция не определена за пределами [-1, 1]
    }
}
```

4. **`double verzier(double x)`** — функция для вычисления значения функции Верзьера Аньези, которая определена как \( \text{V}(x) = \frac{1}{\sqrt{1 - x^2}} \), но только в пределах \(x \in [-1, 1]\).
   
5. **`if (x >= -1 && x <= 1)`** — проверка, находится ли \(x\) в пределах от -1 до 1 (включительно). Если да, то функция вычисляется.

6. **`return 1.0 / sqrt(1 - x * x);`** — если \(x\) в пределах \([-1, 1]\), то мы вычисляем значение функции Верзьера Аньези, используя стандартную формулу.

7. **`else { return -1; }`** — если \(x\) выходит за пределы \([-1, 1]\), то функция не определена, и мы возвращаем значение -1, которое будет использоваться для вывода ошибки.

#### Функция Лемниската Бернулли

```c
double lemniscate(double x) {
    if (x > 0 && x < 1) {
        return sqrt(1 - x * x);
    } else {
        return -1;  // Функция не определена для других значений
    }
}
```

8. **`double lemniscate(double x)`** — функция для вычисления значения функции Лемниската Бернулли, которая вычисляется как \( \text{L}(x) = \sqrt{1 - x^2} \), но только для положительных значений \(x \in (0, 1)\).
   
9. **`if (x > 0 && x < 1)`** — проверка, находится ли \(x\) в пределах от 0 до 1 (не включая 0 и 1). Если да, то функция вычисляется.

10. **`return sqrt(1 - x * x);`** — если \(x\) в пределах \( (0, 1) \), то вычисляем значение функции Лемниската Бернулли.

11. **`else { return -1; }`** — если \(x\) выходит за пределы допустимого диапазона, то функция не определена, и мы возвращаем -1.

#### Функция Квадратичной гиперболы

```c
double hyperbola(double x) {
    if (x != 0) {
        return 1.0 / (x * x);
    } else {
        return -1;  // Функция не определена для x = 0
    }
}
```

12. **`double hyperbola(double x)`** — функция для вычисления значения квадратичной гиперболы \( \text{H}(x) = \frac{1}{x^2} \), которая не определена при \( x = 0 \).
   
13. **`if (x != 0)`** — проверка, что \(x\) не равен 0, так как функция не определена при \(x = 0\).

14. **`return 1.0 / (x * x);`** — если \(x \neq 0\), то вычисляется значение функции квадратичной гиперболы.

15. **`else { return -1; }`** — если \(x = 0\), то функция не определена, и возвращается -1.

### Основная функция `main`

```c
int main() {
    double step = 2 * PI / 41;
```

16. **`double step = 2 * PI / 41;`** — вычисляем шаг для перебора значений от \(-\pi\) до \(\pi\). Так как мы хотим 42 значения (включая \(-\pi\) и \(\pi\)), шаг будет равен \( \frac{2\pi}{41} \).

```c
    FILE *output = fopen("data/door_data.txt", "w");
    if (output == NULL) {
        printf("Error opening file.\n");
        return 1;
    }
```

17. **`FILE *output = fopen("data/door_data.txt", "w");`** — открываем файл для записи результатов. Если файл не существует, он будет создан. Путь к файлу указан как `"data/door_data.txt"`, и файл будет открыт в режиме записи (`"w"`).

18. **`if (output == NULL)`** — проверка, был ли успешно открыт файл. Если файл не удалось открыть (например, из-за отсутствия директории или проблем с правами), выводим сообщение об ошибке и завершаем программу с кодом ошибки `1`.

```c
    for (int i = 0; i < 42; i++) {
        double x = -PI + i * step;
```

19. **`for (int i = 0; i < 42; i++)`** — запускаем цикл для 42 значений \(x\) от \(-\pi\) до \(\pi\), включая оба конца.

20. **`double x = -PI + i * step;`** — вычисляем текущее значение \(x\), начиная с \(-\pi\) и увеличивая на шаг \( \frac{2\pi}{41} \) на каждой итерации.

```c
        double v = verzier(x);
        double l = lemniscate(x);
        double h = hyperbola(x);
```

21. **`double v = verzier(x);`** — вычисляем значение функции Верзьера Аньези для текущего значения \(x\).

22. **`double l = lemniscate(x);`** — вычисляем значение функции Лемниската Бернулли для текущего значения \(x\).

23. **`double h = hyperbola(x);`** — вычисляем значение квадратичной гиперболы для текущего значения \(x\).

```c
        if (v == -1) {
            fprintf(output, "%0.7f | - | ", x);
        } else {
            fprintf(output, "%0.7f | %0.7f | ", x, v);
        }
```

24. **`if (v == -1)`** — если функция Верзьера Аньези не определена для текущего \(x\) (то есть \(v == -1\)), выводим знак "-" вместо значения.

25. **`fprintf(output, "%0.7f | - | ", x);`** — если значение не определено, выводим "-" в столбце, соответствующем функции Верзьера Аньези.

26. **`else { fprintf(output, "%0.7f | %0.7f | ", x, v); }`** — если значение определено, выводим его с точностью до 7 знаков после запятой.

```c
        if (l == -1) {
            fprintf(output, "- | ");
        } else {
            fprintf(output, "%0.7f | ", l);
        }
```

27. **`if (l == -1)`** — проверяем, определена ли функция Лемниската Бернулли для текущего \(x\). Если нет, выводим "-".

28. **`else { fprintf(output, "%0.7f | ", l); }`** — если функция определена, выводим её значение с точностью до 7 знаков.

```c
        if (h == -1) {
            fprintf(output, "-\n");
        } else {
            fprintf(output, "%0.7f\n", h);
        }
```

29. **`if (h == -1)`** — проверяем, определена ли квадратичная гипербола для текущего \(x\). Если нет, выводим "-".

30. **`else { fprintf(output, "%0.7f\n", h); }`** — если функция определена, выводим её значение с точностью до 7 знаков и переходим на новую строку.

```c
   

 fclose(output);
    return 0;
}
```

31. **`fclose(output);`** — закрываем файл после завершения записи.

32. **`return 0;`** — завершаем программу с кодом успеха.

# Quest 5
### Включение библиотек
```c
#include <stdio.h>
#include <math.h>
```
- **`#include <stdio.h>`** — подключает стандартную библиотеку для ввода/вывода. Это позволяет использовать функции `printf` для печати графиков и других сообщений.
- **`#include <math.h>`** — подключает математическую библиотеку, которая предоставляет функции для математических операций. В данном случае используется функция `sqrt` для вычисления квадратного корня.

### Определение констант и параметров
```c
#define PI 3.14159265358979323846
#define X_POINTS 42
#define Y_POINTS 21
```
- **`#define PI 3.14159265358979323846`** — задает точное значение числа \(\pi\), которое используется при вычислениях для определения диапазона значений \(x\) по оси абсцисс.
- **`#define X_POINTS 42`** — количество точек по оси абсцисс, которые будут отображаться на графике. Это 42 точки, что соответствует 42 отсечкам от \(-\pi\) до \(+\pi\).
- **`#define Y_POINTS 21`** — количество строк (или отсечек) по оси ординат, которые будут отображать значения функции. Это 21 строка, чтобы масштабировать график по вертикали.

### Математические функции
В программе есть три функции для вычисления значений математических выражений, которые отображаются на графиках.

#### Функция Верзьера Аньези
```c
double verzier(double x) {
    if (x >= -1 && x <= 1) {
        return 1.0 / sqrt(1 - x * x);
    } else {
        return -1;  // Функция не определена за пределами [-1, 1]
    }
}
```
- **`verzier`** — функция Верзьера Аньези. Она принимает значение \(x\) и вычисляет выражение \( \frac{1}{\sqrt{1 - x^2}} \), но только для значений \(x\), лежащих в диапазоне от -1 до 1 (так как корень из отрицательного числа не существует). Если \(x\) выходит за этот диапазон, функция возвращает `-1`, что указывает на ошибку или неопределенность.

#### Функция Лемниската Бернулли
```c
double lemniscate(double x) {
    if (x > 0 && x < 1) {
        return sqrt(1 - x * x);
    } else {
        return -1;  // Функция не определена для других значений
    }
}
```
- **`lemniscate`** — функция Лемниската Бернулли. Эта функция вычисляет \( \sqrt{1 - x^2} \) для \(x\) в интервале от 0 до 1. Если \(x\) выходит за пределы этого интервала, функция возвращает `-1`.

#### Функция Квадратичной гиперболы
```c
double hyperbola(double x) {
    if (x != 0) {
        return 1.0 / (x * x);
    } else {
        return -1;  // Функция не определена для x = 0
    }
}
```
- **`hyperbola`** — функция квадратичной гиперболы, которая вычисляет \( \frac{1}{x^2} \), но только если \(x \neq 0\), так как деление на ноль невозможно. Если \(x = 0\), функция возвращает `-1`.

### Функция для рисования графика
```c
void plotGraph(double (*func)(double)) {
    // Массив для хранения графика
    char graph[Y_POINTS][X_POINTS + 1];
```
- **`plotGraph`** — функция, которая строит график для функции, переданной как параметр. Она использует двумерный массив `graph` для хранения символов, которые будут представлять график.
- **`char graph[Y_POINTS][X_POINTS + 1]`** — массив размером 21 строка на 42 столбца. Это пространство, где будут храниться символы графика. Мы добавляем один элемент в строку, чтобы в конце строки можно было поставить завершающий нулевой символ (`'\0'`), который сообщает, что строка закончена.

```c
    // Инициализация массива пробелами
    for (int i = 0; i < Y_POINTS; i++) {
        for (int j = 0; j < X_POINTS; j++) {
            graph[i][j] = ' ';
        }
        graph[i][X_POINTS] = '\0';  // Завершаем строку
    }
```
- **Инициализация графика**: Мы заполняем весь массив `graph` пробелами (`' '`), чтобы начальный график был пустым. Каждая строка заканчивается нулевым символом `'\0'`, чтобы правильно вывести строки позже.

```c
    // Вычисление значений функции и отрисовка на графике
    for (int i = 0; i < X_POINTS; i++) {
        double x = -PI + i * (2 * PI / (X_POINTS - 1)); // Расчет x от -PI до PI
        double y = func(x);  // Получаем значение функции
```
- **Цикл по оси абсцисс (X)**: Мы перебираем все 42 точки от \(-\pi\) до \(+\pi\) (включая). В каждой точке рассчитываем значение функции \(y = f(x)\), передавая значение \(x\) в одну из функций (например, `verzier`, `lemniscate`, или `hyperbola`).

```c
        // Преобразуем значение y в индекс строки
        int row = Y_POINTS / 2 - (int)(y * (Y_POINTS / 4)); // Масштабирование по оси ординат
```
- **Масштабирование по оси ординат (Y)**: Мы преобразуем значение функции \(y\) в строку. Значение \(y\) умножается на `(Y_POINTS / 4)`, чтобы привести его к диапазону, соответствующему числу строк на графике. При этом результат сдвигается на половину от количества строк (`Y_POINTS / 2`), чтобы график был расположен в центре.

```c
        // Если значение функции лежит в пределах допустимых значений для ординат
        if (row >= 0 && row < Y_POINTS) {
            graph[row][i] = '*';  // Отметим звездочкой
        }
    }
```
- Если результат масштабирования функции \(y\) находится в пределах допустимого диапазона для оси ординат (от 0 до 20, то есть в пределах строк массива), то ставим символ `*` в соответствующую ячейку графика. Таким образом, формируется график из звездочек.

### Печать графика
```c
    // Печать графика
    for (int i = 0; i < Y_POINTS; i++) {
        printf("%s\n", graph[i]);  // Печать каждой строки графика
    }
}
```
- В этой части мы печатаем все строки массива `graph`, каждая из которых представляет собой одну строку графика, заполненную пробелами или звездочками.

### Основная функция
```c
int main() {
    // Печать графиков для каждой функции
    printf("Graph for Verzier function:\n");
    plotGraph(verzier);  // Печать графика для функции Верзьера
    printf("\nGraph for Lemniscate function:\n");
    plotGraph(lemniscate);  // Печать графика для функции Лемниската
    printf("\nGraph for Hyperbola function:\n");
    plotGraph(hyperbola);  // Печать графика для квадратичной гиперболы
    
    return 0;
}
```
- В основной функции вызываются три раза функция `plotGraph` для разных математических функций: Верзьера, Лемниската и Квадратичной гиперболы. Каждый вызов функции рисует график соответствующей функции.

### Итог:
- Код вычисляет значения математических функций в каждой точке и строит график, используя символы `*`. Графики отображаются в терминале как текст, где каждая строка представляет собой вертикальную часть графика, а каждая звезда `*` — точку на графике.
