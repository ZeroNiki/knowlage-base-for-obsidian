Алгоритм Дейкстры лежит в основе многих востребованных современных сервисов, к числу которых относятся GPS навигация и маршрутизация состояния канала сетевого уровня.

## Что делает алгоритм Дейкстры

Алгоритм Дейкстры **находит кратчайший путь между двумя вершинами графа**. Следовательно, если математические задачи моделируется при помощи графа, используя алгоритм Дейкстры, можно найти кратчайший путь между вершинами.

## Алгоритм Дейкстры

Перед непосредственным составлением кода, осветим ключевые моменты темы:

1. Главное условие: отрицательных длин ребер не бывает.
2. Алгоритм Дейкстры изначально создавался **для поиска кратчайшего пути** между двумя конкретными узлами. Однако сегодня он также широко используется для поиска кратчайших путей между узлом источника и _всеми_ остальными узлами. В статье будет рассмотрен второй вариант. Для осуществления первого случая понадобится просто остановить алгоритм сразу после того, как узел назначения будет добавлен в набор `seen`. По ходу дела все станет намного понятнее.

Окей, примемся за дело. Нам нужно найти исходным узлом и всеми другими узлами (или узлом назначения), однако проверять КАЖДУЮ возможную комбинацию отправления-назначения не хочется. При наличии крупного графа на это потребуется огромное количество времени, и большая часть проверенных путей в конечном итоге окажется ненужной. По этой причине, пойдем напролом и задействуем _жадный_ подход. Наслаждайтесь моментом, ведь это тот редкий случай, когда жадность будет вознаграждена.

Итак, что мы понимаем под _жадным_ алгоритмом? По сути, это значит, что принятые решения будут обусловлены самым оптимальным выбором на данный конкретный момент времени. Метод подойдет далеко не для каждого случая. К примеру, при реализации шахматного бота фокус точно не пройдет — зачем брать враждебного ферзя, если через ход это обернется шахом со стороны противника. Для таких ситуаций больше подойдет [minimax](https://www.geeksforgeeks.org/minimax-algorithm-in-game-theory-set-1-introduction/). В рассматриваемом сейчас случае жадный алгоритм действительно является наилучшим вариантом, который значительно сокращает число проверок, что нужно совершить без потери точности. Как?

Скажем, мы находимся в исходном узле. Предположим, что начальное **предварительное расстояние** от узла источника до каждого другого узла в графе является _бесконечностью_ (перепроверим позже). Известно, что по умолчанию расстояние от узла источника до этого же узла источника минимально (0), ведь отрицательных длин ребер быть не может. Наш исходный узел осматривает все соседние узлы и обновляет **предварительное** расстояние от узла источника до длины ребра от узла источника до конкретного соседнего элемента (плюс 0). Обратите внимание, что НУЖНО проверить каждого ближайшего соседа, этого никак не пропустить. Затем алгоритм делает тот самый _жадный_ выбор для следующей оценки узла, который находится на ближайшем расстоянии к источнику. У нас исходный узел отмечен как `visited`, поэтому к нему можно не возвращаться и сразу перейти к следующему узлу.

Теперь задумаемся, где мы сейчас находимся в плане логики, так как это важно для реализации. Узел, что сейчас оценивается (ближайший к источнику) больше НИКОГДА не будет оцениваться вновь в плане кратчайшего пути от исходного узла. Его **предварительное расстояние** теперь стало точным расстоянием. Хотя вполне возможно, что пути от исходного узла к данному узлу могут проходить через иные маршруты, можно с уверенностью сказать, что они будут затратнее, нежели текущий путь. Он был выбран ввиду того, что _был кратчайшим_ по сравнению с любым другим узлом, связанным с источником. Следовательно, любой другой путь _будет длиннее_, чем текущее расстояние от исходного узла до рассматриваемого узла.

При использовании графика из примера в случае установки исходного узла как `А`, мы бы назначили предварительные расстояния для узлов `B`, `C` и `E`. Поскольку у `E` было кратчайшее расстояние от `A`, после этого был посещен узел `E`. И теперь, хотя наверняка есть несколько других способов добраться из `А` до `Е`, они будут затратнее, нежели текущее расстояние `А` → `Е`. Другие маршруты должны проходить через `B` или `С`, а в результате проверки стало ясно, что они дальше от `A`, чем `E`. Жадный выбор был сделан, а это ограничивает общее количество проверок, которые нам нужно сделать, и при этом точность не теряется. Неплохо.

Продолжим логическую цепочку с использованием графа из примера. Просто повторим для `E` действия, сделанные для `A`. Обновляются все ближайшие соседние элементы к `E` с предварительным расстоянием, равным `length(A у E) + edge_length(E к соседнему элементу)`. Это верно в том случае, **ЕСЛИ** данное расстояние меньше, чем текущее предварительное расстояние, или же предварительное расстояние еще не было установлено.

> **Обратите внимание**: Для достижения данной функциональности здесь просто инициализируются все предварительные расстояния до бесконечности.

Далее делается жадный выбор касательно того, какой узел должен оцениваться следующим. Выбирается один узел из графа с наименьшим предварительным расстоянием, и добавляется `E` к набору `seen nodes`. Теперь он повторно оцениваться не будет. У данного нового узла та же гарантия, что что и `E` — его предварительное расстояние от `A` является определенным минимальным расстоянием от `A`. Чтобы понять это, давайте оценим возможности (хотя они могут не соответствовать графу примера, для ясности используем те же названия). Если следующий узел является соседом `E`, но не `A`, то он будет выбран, потому что его временное расстояние все еще короче, чем любого другого прямого соседа `A`. По этой причине нет другого возможного кратчайшего пути, только через `E`. Если следующий выбранный узел будет непосредственным соседом `A`, то есть вероятность, что этот узел обеспечит более короткий путь к некоторым из соседей `E`, чем сам `E`.

## Обзор кода алгоритма Дейкстры на Python

Давайте более четко и формально рассмотрим процесс реализации алгоритма Дейкстры.

ИНИЦИАЛИЗАЦИЯ

1. Установите `provisional_distance` для всех узлов от исходного узла до бесконечности.
2. Определите пустой набор `seen_nodes`. Данный набор гарантирует, что узел, у которого уже есть кратчайший путь, не будет повторно рассмотрен, а также то, что не будут рассматриваться пути через узел, у которого более короткий путь к источнику, чем текущий путь. Помните, что узлы входят в `seen_nodes` **только** **после доказательства** того, что в наличии есть абсолютное кратчайшее расстояние (а не только предварительное расстояние). Набор используется для получения времени поиска `O(1)` вместо многократного выполнения поиска через массив `O(n)`.
3. Установите `provisional_distance` для исходного узла со значением 0, и массив, представляющий перескоки для простого включения самого исходного кода. Это будет полезно позже, когда мы проследим выбранный для графа путь для расчета минимального расстояния.

ПРОЦЕДУРА ИТЕРАЦИИ

1. Пока (while) все узлы увидеть (`seen`) не удалось. Или, в случае поиска одного узла назначения, пока не удалось увидеть (`seen`) данный узел назначения.
2. Установите `current_node` для узла c самым малым предварительным расстоянием `provisional_distance` во всем графе. Обратите внимание, что для первой [итерации](https://python-scripts.com/itertools "итерации в Python") это будет исходный узел `source_node`, так как предварительное расстояние `provisional_distance` установлено на 0.
3. Добавьте текущий узел `current_node` к набору просмотренных узлов `seen_nodes`.
4. Обновите `provisional_distance` каждого соседнего элемента `current_node` до (абсолютного) расстояния от `current_node` до `source_node` вдобавок к длине ребра от `current_node` к данному соседнему элементу, ЕСЛИ данное значение меньше, чем текущее значение соседнего `provisional_distance`. Если у соседнего элемента еще не было набора предварительного расстояния, помните, что он инициализирован до бесконечности, и по этой причине должен быть больше, чем данная сумма. При обновлении `provisional_distance` также обновляются «перескоки», которые были сделаны для получения расстояния, задействуя конкатенацию перескоков `current_node` к исходному узлу с самим `current_node`.
5. Завершение цикла **while**.

## Алгоритм Дейкстры через схемы и изображения

![Алгоритм Дейкстры](https://python-scripts.com/wp-content/uploads/2019/11/Алгоритм-Дейкстры_01.jpg)

![Алгоритм Дейкстры](https://python-scripts.com/wp-content/uploads/2019/11/Алгоритм-Дейкстры_02.jpg)

Обратите внимание, что в дальнейшем можно посетить либо `D`, либо `B`. Сейчас мы посетим `B`.

![Алгоритм Дейкстры](https://python-scripts.com/wp-content/uploads/2019/11/Алгоритм-Дейкстры_03.jpg)

![Алгоритм Дейкстры](https://python-scripts.com/wp-content/uploads/2019/11/Алгоритм-Дейкстры_04.jpg)

![Алгоритм Дейкстры](https://python-scripts.com/wp-content/uploads/2019/11/Алгоритм-Дейкстры_05.jpg)

![Алгоритм Дейкстры](https://python-scripts.com/wp-content/uploads/2019/11/Алгоритм-Дейкстры_06.jpg)

Здесь программа завершается. В результате мы получаем **кратчайшие пути для каждого узла графа**.

## Python код для алгоритма Дейкстры

Посмотрим, как будет выглядеть **реализация алгоритма Дейстры в Python**. Это экземпляр метода внутри раннее используемого класса `Graph`, который задействует преимущества других методов и структуры:

```python
   def dijkstra(self, node):
        # Получает индекс узла (или поддерживает передачу int)
        nodenum = self.get_index_from_node(node)
        # Заставляет массив отслеживать расстояние от одного до любого узла
        # в self.nodes. Инициализирует до бесконечности для всех узлов, кроме 
        # начального узла, сохраняет "путь", связанный с расстоянием. 
        # Индекс 0 = расстояние, индекс 1 = перескоки узла
        dist = [None] * len(self.nodes)
        for i in range(len(dist)):
            dist[i] = [float("inf")]
            dist[i].append([self.nodes[nodenum]])
        
        dist[nodenum][0] = 0
        # Добавляет в очередь все узлы графа
        # Отмечает целые числа в очереди, соответствующие индексам узла
        # локаций в массиве self.nodes 
        queue = [i for i in range(len(self.nodes))]
        # Набор увиденных на данный момент номеров 
        seen = set()
        while len(queue) > 0:
            # Получает узел в очереди, который еще не был рассмотрен
            # и который находится на кратчайшем расстоянии от источника
            min_dist = float("inf")
            min_node = None
            for n in queue: 
                if dist[n][0] < min_dist and n not in seen:
                    min_dist = dist[n][0]
                    min_node = n
            
            # Добавляет мин. расстояние узла до увиденного, убирает очередь
            queue.remove(min_node)
            seen.add(min_node)
            # Получает все следующие перескоки
            connections = self.connections_from(min_node)
            # Для каждой связи обновляет путь и полное расстояние от  
            # исходного узла, если полное расстояние меньше
            # чем текущее расстояние в массиве dist
            for (node, weight) in connections: 
                tot_dist = weight + min_dist
                if tot_dist < dist[node.index][0]:
                    dist[node.index][0] = tot_dist
                    dist[node.index][1] = list(dist[min_node][1])
                    dist[node.index][1].append(node)
        return dist
```

При использовании данного метода можно протестировать нашу картинку:

```python 
a = Node("A")
b = Node("B")
c = Node("C")
d = Node("D")
e = Node("E")
f = Node("F")

w_graph = Graph.create_from_nodes([a,b,c,d,e,f])

w_graph.connect(a,b,5)
w_graph.connect(a,c,10)
w_graph.connect(a,e,2)
w_graph.connect(b,c,2)
w_graph.connect(b,d,4)
w_graph.connect(c,d,7)
w_graph.connect(c,f,10)
w_graph.connect(d,e,3)

print([(weight, [n.data for n in node]) for (weight, node) in w_graph.dijkstra(a)])
```

Для получения читабельного для людей вывода нужно отметить объекты узла в их `data`. Результат станет следующим:

```python
[(0, [‘A’]), (5, [‘A’, ‘B’]), (7, [‘A’, ‘B’, ‘C’]), (5, [‘A’, ‘E’, ‘D’]), (2, [‘A’, ‘E’]), (17, [‘A’, ‘B’, ‘C’, ‘F’])]
```

десь каждый [кортеж](https://python-scripts.com/lists-tuples-dictionaries#tuple "tuple в python") — `(total_distance, [hop_path])`. Это совпадает с рассматриваемой картинкой.

## Быстрый способ реализации алгоритма Дейкстры в Python

На данный момент тем, кто заинтересован только в функциональности, хватит предоставленного материала. Однако, тем, кому важна скорость стоит продолжить чтение.

Остановимся на одном довольно важном моменте. В каждой итерации нам нужно найти узел с кратчайшим предварительным расстоянием, что требуется для следующего жадного решения. Сейчас осматривается `list`, вызывая `queue` (используя данные значения в `dist`) с целью получения желаемого. У данного `queue` может быть максимальная длина `n`, что является числом узлов. Итерация по этому списку является операцией `O(n)`, которую мы выполняем в каждой итерации [цикла while](https://python-scripts.com/loops-for-while#while "цикл while в Python"). Так как **цикл while** продолжается до тех пор, пока не будет просмотрен (`seen`) каждый узел, сейчас операция `O(n)` совершается `n` раз. Наш алгоритм — `O(n2)`. Это не очень хорошо, но и это не все.

Если взглянуть на реализацию матрицы смежности в Graph, можно заметить, что для нахождения связи нам пришлось осмотреть весь ряд (размера n). Это еще одна операция O(n) в цикле while. Как это исправить? Во-первых, можно использовать [кучу](https://ru.wikipedia.org/wiki/Куча_(структура_данных)) для получения минимального предварительного расстояния в `O(lg(n))`[[Логарифмическая сложность - O(log n)]] времени вместо `O(n)`[[O(n) Линейная сложность]] времени (при бинарной куче — отметьте, что куча Фибоначчи способна на это в `O(1)`[[О(1) Простая сложность]]). Во-вторых, можно реализовать граф при помощи списка смежности, где у каждого узла есть список связанных узлов. Получается, что осматривать все узлы на наличие существующей связи не потребуется. Это показывает, почему важно понимать то, как мы представляем структуры данных. В случае реализаци кучи при помощи представления матрицы смежности асимптомическое время выполнения запуска алгоритма изменено не будет. (На заметку: Если вам не знакома нотация big-O, можете просмотреть [данную статью](https://medium.com/cantors-paradise/basics-of-big-o-sorting-94d0c04d0f53)).

