Метод скользящего окна — алгоритм трансформации, позволяющий сформировать из членов временного ряда набор данных, который может служить обучающим множеством для построения модели прогнозирования.

Под окном в данном случае понимается временной интервал, содержащий набор значений, которые используются для формирования обучающего примера. В процессе работы алгоритма окно смещается по временной последовательности на единицу наблюдения, и каждое положение окна образует один пример.

Например, если еженедельно поступают данные о продажах в течение 50 недель и установлено окно в 5 недель, то в первом примере используются данные с 1 по 5 неделю, а целевым значением будут данные за 6-ю неделю. Во втором случае используются данные со 2 по 6 неделю, а в качестве целевого значения берутся данные за 7-ю и т.д.

![[Pasted image 20240810134717.png]]

Если требуется построить прогноз не на одну единицу наблюдения, а на несколько, то в качестве целевых выбирается соответствующее число значений, которое называется горизонтом прогноза. Количество наблюдений ряда, которые берутся в качестве входных значений называется глубиной прогноза.

## На python
```python
class Solution:
    def alg(self, arr, k) -> int:
        n = len(arr)

        if n <= k:
            print("Invalid")
            return -1

        window_sum = sum(arr[:k])

        max_sum = window_sum

        for i in range(n - k):
            window_sum = window_sum - arr[i] + arr[i + k]
            max_sum = max(window_sum, max_sum)

        return max_sum


obj = Solution()
arr = [5, 2, -1, 0, 3]
k = 3
print(obj.alg(arr, k))
```

```
Input: [5, 2, -1, 0, 3]
Window size: 3
Output: 6 (Max sum)
```

`n = len(arr)` - длинна массива

`window_sum` - создание подмассива

`max_sum` - максимальная сумма подмассива

```python
for i in range(n - k):
	window_sum = window_sum - arr[i] + arr[i+k]
	max_sum = max(window_sum, max_sum)

return max_sum
``` 

Создаём цикл который будет пробигаться по оснавному массиву 
`range(n-k)` = `range(5-3)` или же arr[0 1 2]

`window_sum = window_sum - arr[i] + arr[i+k]` - выполняется движение по основному массиву

`max_sum = max(window_sum, max_sum)` - получение макс суммы подмасива

