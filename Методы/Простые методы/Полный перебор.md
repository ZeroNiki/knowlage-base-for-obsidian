# Полный перебор в теории

**Полный перебор** (или **метод «грубой силы»**, [англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") brute force) — метод решения [математических задач](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8 "Математические задачи"). Относится к классу [методов поиска решения исчерпыванием всевозможных вариантов](https://ru.wikipedia.org/w/index.php?title=%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0_%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B8%D1%81%D1%87%D0%B5%D1%80%D0%BF%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC&action=edit&redlink=1 "Метод поиска решения исчерпыванием (страница отсутствует)")[en](https://en.wikipedia.org/wiki/Proof_by_exhaustion "en:Proof by exhaustion"). [Сложность](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B9 "Теория сложности вычислений") полного перебора зависит от количества всех возможных решений задачи. Если пространство решений очень велико, то полный перебор может не дать результатов в течение нескольких лет или даже столетий.

------

## Практика на Python

В программировании очень часто встает задача организации полного перебора, например, для поиска оптимального случая или для подсчета всех возможных комбинаций.

В случае, когда перебираются всего два-четыре значения допустимо использовать вложенные циклы.

Например, выведем все троичные числа, записываемые в двух разрядах, в том числе с незначащими нулями:

```python
for x in range(3):

    for y in range(3):

        print(x, y, sep='')
```

#### Поиск двух наиболее близких по значению элементов

Найдем два наиболее близких по значению элемента при помощи алгоритма поиска минимума и вложенных циклов. Для этого переберем всевозможные пары значений.
```python
A = list(map(int, input().split()))

min_diff = abs(A[1]-A[0]) + 1

for k in range(1, len(A)):

    for i in range(k):

        if abs(A[k] - A[i]) < min_diff:

            min_diff = abs(A[k] - A[i])

            x = A[i]

            y = A[k]

print(x, y)
```