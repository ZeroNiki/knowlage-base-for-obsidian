В Python существуют специальные функции-декораторы, такие как **`@classmethod`**, **`@staticmethod`** и **`@property`**, которые используются для изменения поведения методов в классах. Давайте разберём, что они делают и как применяются.

### 1. **`@classmethod`**

Декоратор **`@classmethod`** используется для создания методов класса, которые могут работать с самим классом (а не с экземпляром класса). При вызове метода, декорированного `@classmethod`, первым аргументом передаётся сам класс, а не объект (экземпляр).

#### Синтаксис:
```python
class MyClass:
    @classmethod
    def my_class_method(cls, arg1, arg2):
        # cls - это ссылка на сам класс
        return f"Работаем с классом {cls} и аргументами {arg1}, {arg2}"
```

#### Пример:
```python
class MyClass:
    class_variable = "Я принадлежу классу!"

    @classmethod
    def show_class_variable(cls):
        return cls.class_variable

# Вызов через класс
print(MyClass.show_class_variable())  # Выведет: Я принадлежу классу!

# Вызов через экземпляр
obj = MyClass()
print(obj.show_class_variable())  # Также выведет: Я принадлежу классу!
```

**Когда использовать?**
- Когда метод должен работать с классом, а не с конкретным экземпляром.
- Часто используется для создания альтернативных конструкторов.

#### Пример альтернативного конструктора:
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @classmethod
    def from_birth_year(cls, name, birth_year):
        age = 2024 - birth_year
        return cls(name, age)

# Создание объекта через обычный конструктор
person1 = Person("Alice", 30)

# Создание объекта через альтернативный конструктор
person2 = Person.from_birth_year("Bob", 1990)

print(person2.name, person2.age)  # Выведет: Bob 34
```

### 2. **`@staticmethod`**

Декоратор **`@staticmethod`** используется для создания статических методов. Статический метод не принимает ни экземпляр (`self`), ни класс (`cls`) в качестве первого аргумента. Это по сути обычная функция, которая размещена внутри класса для логической организации.

#### Синтаксис:
```python
class MyClass:
    @staticmethod
    def my_static_method(arg1, arg2):
        # Нет ни self, ни cls
        return f"Работаем с аргументами {arg1}, {arg2}"
```

#### Пример:
```python
class MathOperations:
    @staticmethod
    def add(a, b):
        return a + b

# Вызов через класс
print(MathOperations.add(5, 3))  # Выведет: 8

# Вызов через экземпляр
math_obj = MathOperations()
print(math_obj.add(10, 4))  # Также выведет: 14
```

**Когда использовать?**
- Когда метод не зависит от экземпляра или класса и должен работать только с переданными аргументами.
- Для логического объединения функций с классом, когда они связаны по смыслу, но не требуют доступа к атрибутам класса или объекта.

### 3. **`@property`**

Декоратор **`@property`** позволяет создать **свойства** (property) — методы, которые можно вызывать как атрибуты. Это удобно для инкапсуляции: вы можете скрыть сложную логику за простым интерфейсом доступа к атрибутам.

#### Синтаксис:
```python
class MyClass:
    @property
    def my_property(self):
        return "Это свойство"
```

#### Пример:
```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        if value < 0:
            raise ValueError("Радиус не может быть отрицательным")
        self._radius = value

    @property
    def area(self):
        from math import pi
        return pi * (self._radius ** 2)

# Создаём объект
circle = Circle(5)

# Доступ к радиусу через свойство
print(circle.radius)  # Выведет: 5

# Изменяем радиус через setter
circle.radius = 10

# Вычисление площади
print(circle.area)  # Выведет: 314.159...
```

**Когда использовать?**
- Когда вы хотите предоставить "умный" доступ к атрибутам объекта. Например, чтобы автоматически обновлять связанные данные при изменении одного из атрибутов или чтобы контролировать доступ к данным.
- Для создания атрибутов, которые рассчитываются на основе других данных (например, площадь круга, как в примере выше).

### Отличия между ними:

| Декоратор      | Описание                                                                                                                                                  | Когда использовать                                                                                                         |
|----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------|
| **`@classmethod`** | Метод, который работает с самим классом. Первым аргументом принимает ссылку на класс (`cls`).                                                             | Когда нужен метод, который работает с классом (например, альтернативные конструкторы).                                      |
| **`@staticmethod`** | Метод, который не зависит ни от экземпляра, ни от класса. По сути, это обычная функция, но организованная внутри класса.                                 | Когда метод не использует ни класс, ни объект, но логически связан с классом.                                              |
| **`@property`**     | Позволяет обращаться к методу как к атрибуту. Можно также определить `setter` и `deleter`, чтобы управлять изменением и удалением атрибута.              | Когда нужно создать вычисляемые атрибуты или инкапсулировать доступ к данным.                                              |

### Заключение:
- **`@classmethod`** используется для работы с классом.
- **`@staticmethod`** — это независимая функция, помещённая внутрь класса для удобства.
- **`@property`** позволяет создать удобные вычисляемые или защищённые атрибуты, к которым можно обращаться как к обычным свойствам объекта.