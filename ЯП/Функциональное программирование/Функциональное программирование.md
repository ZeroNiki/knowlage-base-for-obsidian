

_Примеры языков: Haskell, Erlang, Scala, F#, OCaml, ELM, Lisp._

К современной декларативной парадигме прежде всего относится функциональное программирование. В строгом функциональном подходе считается, что все функции чистые и не имеют побочных эффектов. Гость может заказать хоть тысячу раз тыквенный суп, и каждый раз официант принесёт ему одно и то же блюдо. Результат функции всегда будет одинаковым. Но в реальном ресторане на десятый раз закончились бы сливки 20% и их бы заменили на 10%, на двадцатый — закончилась бы и тыква, а функция стала бы выдавать ошибку «невозможно приготовить тыквенный суп». Это и есть побочный эффект — то, что изменилось в мире при работе функции, о чём пользователь может не знать.

Чтобы решить эту проблему, при функциональном подходе нельзя просто заказать суп, а нужно предъявить все продукты, необходимые для приготовления. То, что от них останется, будет возвращено в качестве результата вместе с самим супом.

![](https://avatars.mds.yandex.net/get-lpc/1220100/21ebd9d0-db33-494e-9b87-1ce3537eef53/width_1280_q70)

На кухне готовили пюре и суп. В рецепт внесли изменение — заменили соль в пюре, но забыли про побочный эффект

Минус побочных эффектов в том, что их сложно учитывать. Предположим, повар готовит два блюда — картофельное пюре и тыквенный суп. Он отмеряет для них 20 грамм соли. При приготовлении пюре расходуется половина соли — 10 грамм. Оставшиеся 10 грамм повар оставляет на столе, и это становится побочным эффектом приготовления пюре. Затем повар готовит тыквенный суп и добавляет в него остаток соли со стола. Позже оказывается, что шеф решил внести в рецепт изменение — теперь нужно использовать в пюре сванскую соль вместо обычной. На столе остаётся 20 грамм соли вместо десяти, которые повар насыпает в суп, и в итоге получает пересоленное блюдо. Также и в программировании: побочные эффекты трудно учитывать при изменении программы.

В функциональных языках побочных эффектов нет, поэтому нет и понятия изменения объектов. Функция не меняет старый объект, а возвращает новый. Это всё равно что каждый день покупать новый календарь вместо того, чтобы перевернуть лист старого. В большинстве случаев такие напрасные траты может оптимизировать транслятор — приложение, которое будет решать, как именно исполнять код.