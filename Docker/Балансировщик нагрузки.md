## 1. Общая архитектура Docker Swarm

Когда создаётся сервис в Docker Swarm (через `docker service create` или `docker stack deploy`), Swarm:

* создает нужное количество **тасков (tasks)** — это контейнеры, связанные с сервисом;
* размещает их на разных **нодах (nodes)** кластера;
* настраивает **встроенный балансировщик нагрузки**.

---

## 2. Уровни балансировки в Swarm

В Docker Swarm существует два уровня балансировки.

### 2.1. Балансировка на уровне ingress (внешняя)

Если при создании сервиса публикуется порт, например:

```bash
docker service create --name web --replicas 3 --publish 80:80 nginx
```

Swarm создаёт **ingress mesh network**.
Любой узел кластера начинает принимать трафик на указанный порт (в примере — 80).
Входящие запросы могут быть направлены на любой контейнер сервиса, даже если он находится на другой ноде.

Для маршрутизации используется **IPVS** — подсистема ядра Linux, реализующая балансировку на уровне L4 (TCP/UDP).
Алгоритм распределения — **round-robin** (поочерёдное распределение запросов).

Таким образом:

* Любой узел может принимать входящие подключения;
* Трафик доставляется к одному из контейнеров через overlay-сеть, если он запущен на другой ноде.

---

### 2.2. Балансировка на уровне сервисов (внутренняя)

Если один сервис обращается к другому по имени (например, `http://backend:8080`), используется **внутренний балансировщик**.
В этом случае:

* DNS Swarm возвращает виртуальный IP (VIP) для имени `backend`;
* Этот VIP балансирует трафик между всеми задачами сервиса через IPVS;
* Алгоритм — также round-robin.

Таким образом, сервисы внутри Swarm видят друг друга как единый виртуальный адрес, а не отдельные контейнеры.

---

## 3. Принцип распределения задач (tasks) по нодам

Когда создаётся или масштабируется сервис, встроенный планировщик Swarm определяет, где разместить задачи.
Он учитывает следующие параметры:

1. **Равномерность загрузки** — Swarm стремится равномерно распределить контейнеры по доступным нодам.
2. **Ресурсы узлов** — CPU и RAM.
3. **Ограничения и предпочтения** (если заданы):

   * `--constraint 'node.labels.zone==eu'`
   * `--placement-pref 'spread=node.labels.rack'`
4. **Антиаффинность по умолчанию** — Swarm старается не размещать несколько задач одного сервиса на одной ноде, если есть другие свободные.

---

## 4. Алгоритмы балансировки

Swarm использует **IPVS**, который поддерживает разные алгоритмы, но по умолчанию применяется **round-robin**.
Это означает, что каждый новый запрос направляется последовательно к разным контейнерам.

---

## 5. Routing Mesh

**Routing Mesh** — это механизм, обеспечивающий:

* доступность опубликованных портов на всех нодах кластера;
* прозрачную маршрутизацию запросов к контейнерам;
* балансировку трафика на уровне L4.

Он реализуется с помощью:

* **Overlay-сетей**;
* **iptables** и **IPVS** внутри узлов.

---

## 6. Пример прохождения запроса

1. Клиент отправляет запрос `http://node1:80`.
2. На узле `node1` работает IPVS, который выбирает один из контейнеров сервиса `web`.
3. Если выбранный контейнер находится на другой ноде, запрос перенаправляется через overlay-сеть.
4. Контейнер обрабатывает запрос и возвращает ответ по тому же маршруту.

---

## 7. Итоговая схема

| Уровень                  | Механизм            | Метод балансировки                        |
| ------------------------ | ------------------- | ----------------------------------------- |
| Внешний (Ingress)        | Routing Mesh (IPVS) | Round-robin между всеми задачами сервиса  |
| Внутренний (Service VIP) | DNS + IPVS          | Round-robin между задачами                |
| Распределение задач      | Swarm Scheduler     | По ресурсам, ограничениям и равномерности |