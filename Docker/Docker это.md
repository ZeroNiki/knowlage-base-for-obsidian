Docker - это технология для упровления контейнерами

## Что такое **контейнеры**

**Контейнеры** — это способ стандартизации развертки приложения и отделения его от общей инфраструктуры. Экземпляр приложения запускается в изолированной среде, не влияющей на основную операционную систему. 

Разработчикам не нужно задумываться, в каком окружении будет работать их приложение, будут ли там нужные настройки и зависимости. Они просто создают приложение, упаковывают все зависимости и настройки в некоторый единый образ. Затем этот образ можно запускать на других системах, не беспокоясь, что приложение не запустится.

**Docker** — это платформа для разработки, доставки и запуска контейнерных приложений. Docker позволяет создавать контейнеры, автоматизировать их запуск и развертывание, управляет жизненным циклом. Он позволяет запускать множество контейнеров на одной хост-машине.

Контейнеризация похожа на виртуализацию, но это не одно и то же. Виртуализация запускает полноценный хост на гипервизоре со своим виртуальным оборудованием и операционной системой. При этом внутри одной ОС можно запустить другую ОС. В случае контейнеризации процесс запускается прямо из ядра основной операционной системы и не виртуализирует оборудование. Это означает, что контейнеризованное приложение может работать только в той же ОС, что и основная. Контейнеры не виртуализируют оборудование, поэтому потребляют меньше ресурсов.

## Чем Docker отличается от виртуальной машины?
Первоначально Docker использовал контейнеры LinuX (LXC), но позже перешел на runC (ранее известный как libcontainer), который работает в той же операционной системе, что и его хост. Это позволяет ему совместно использовать большую часть ресурсов операционной системы хоста. Кроме того, он использует многоуровневую файловую систему (AuFS) и управляет сетью.

AuFS — это многоуровневая файловая система, поэтому вы можете объединить часть, доступную только для чтения, и часть, предназначенную для записи. Можно было бы сделать общие части операционной системы доступными только для чтения (и совместно использовать все ваши контейнеры), а затем предоставить каждому контейнеру собственное монтирование для записи.

Итак, допустим, у вас есть образ контейнера размером 1 ГБ; Если вы хотите использовать полную виртуальную машину, вам потребуется 1 ГБ x необходимое количество виртуальных машин. С помощью Docker и AuFS вы можете разделить большую часть 1 ГБ между всеми контейнерами, и если у вас 1000 контейнеров, у вас все равно может быть чуть более 1 ГБ места для ОС контейнеров (при условии, что все они используют один и тот же образ ОС). .

Полностью виртуализированная система получает собственный набор ресурсов, выделяемых для нее, и обеспечивает минимальное совместное использование. Вы получаете большую изоляцию, но она намного тяжелее (требует больше ресурсов). С Docker вы получаете меньшую изоляцию, но контейнеры легкие (требуют меньше ресурсов). Таким образом, вы можете легко запустить на хосте тысячи контейнеров, и он даже не моргнет. Попробуйте сделать это с Xen, и, если у вас нет действительно большого хоста, я не думаю, что это возможно.

Запуск полной виртуализированной системы обычно занимает несколько минут, тогда как контейнеры Docker/LXC/runC занимают секунды, а часто даже меньше секунды.

У каждого типа виртуализированной системы есть свои плюсы и минусы. Если вам нужна полная изоляция с гарантированными ресурсами, лучше всего использовать полноценную виртуальную машину. Если вы просто хотите изолировать процессы друг от друга и запускать их массу на хосте разумного размера, то Docker/LXC/runC, похоже, подойдет вам.

Для получения дополнительной информации ознакомьтесь с этим набором сообщений в блоге, которые хорошо объясняют, как работает LXC.

    Почему развертывание программного обеспечения в образе Docker (если это правильный термин) проще, чем простое развертывание в согласованной производственной среде?

Развертывание согласованной производственной среды легче сказать, чем сделать. Даже если вы используете такие инструменты, как Chef и Puppet, всегда есть обновления ОС и другие вещи, которые меняются в зависимости от хоста и среды.

Docker дает вам возможность делать снимки ОС в общий образ и упрощает развертывание на других хостах Docker. Локально, dev, qa, prod и т.д.: всё тот ​​же образ. Конечно, вы можете сделать это с помощью других инструментов, но не так легко и быстро.

Это отлично подходит для тестирования; допустим, у вас есть тысячи тестов, которым необходимо подключиться к базе данных, и каждому тесту нужна чистая копия базы данных, и он будет вносить изменения в данные. Классический подход к этому — сбрасывать базу данных после каждого теста либо с помощью специального кода, либо с помощью таких инструментов, как Flyway — это может занять очень много времени и означает, что тесты необходимо запускать последовательно. Однако с помощью Docker вы можете создать образ своей базы данных и запускать по одному экземпляру для каждого теста, а затем запускать все тесты параллельно, поскольку вы знаете, что все они будут выполняться с одним и тем же снимком базы данных. Поскольку тесты выполняются параллельно и в контейнерах Docker, они могут выполняться на одном и том же компьютере одновременно и завершаться намного быстрее. Попробуйте сделать это с полной виртуальной машиной.

Из комментариев...

    Интересный! Полагаю, меня все еще смущает понятие «снимок ОС». Как это сделать, не создавая образа ОС?

Что ж, посмотрим, смогу ли я объяснить. Вы начинаете с базового образа, затем вносите изменения и фиксируете эти изменения с помощью Docker, и он создает образ. Данное изображение содержит только отличия от базового. Если вы хотите запустить свой образ, вам также понадобится база, и он накладывает ваш образ поверх базы, используя многоуровневую файловую систему: как упоминалось выше, Docker использует AuFS. AuFS объединяет разные слои, и вы получаете то, что хотите; вам просто нужно запустить его. Вы можете продолжать добавлять все больше и больше изображений (слоев), и при этом будут сохраняться только различия. Поскольку Docker обычно строится на основе готовых образов из реестра, вам редко придется делать снимок всей ОС самостоятельно.

[Источник](https://stackoverflow.com/questions/16047306/how-is-docker-different-from-a-virtual-machine)

## Преимущества использования контейнеров Docker

Контейнеры упрощают работу как программистам, так и администраторам, которые развертывают эти приложения.

### Docker решает проблемы зависимостей и рабочего окружения

Контейнеры позволяют упаковать в единый образ приложение и все его зависимости: библиотеки, системные утилиты и файлы настройки. Это упрощает перенос приложения на другую инфраструктуру.

Например, разработчики создают приложение в системе разработки — там все настроено, приложение работает. Когда оно готово, его нужно перенести в систему тестирования, а затем в продуктивную среду. Если в одной из них нет нужной зависимости, приложение не будет работать. Программистам придется отвлечься от разработки и совместно с командой поддержки разобраться в ситуации.

В контейнерах такой проблемы нет, так как они содержат в себе все необходимое для запуска приложения. Специалисты занимаются разработкой, а не решением инфраструктурных проблем.

### Изоляция и безопасность

Контейнер — это набор процессов, изолированных от основной операционной системы. Приложения работают только внутри контейнеров и не имеют доступа к основной операционной системе. Это повышает безопасность приложений:они не смогут случайно или умышленно навредить основной системе. Если приложение в контейнере завершится с ошибкой или зависнет, это никак не затронет основную ОС.

### Ускорение и автоматизация развертывания приложений и масштабируемость

Контейнеры упрощают развертывание приложений. В классическом подходе для установки программы нужно совершить несколько действий: выполнить скрипт, изменить файлы настроек и так далее. В этом процессе не исключена вероятность человеческой ошибки: пользователь запустит скрипт два раза, перепутает последовательность или что-то не поймет. Контейнеры позволяют полностью автоматизировать этот процесс, так как включают в себя все нужные зависимости и порядок выполнения действий.

Также контейнеры упрощают развертывание на нескольких серверах. В классическом подходе для того, чтобы развернуть одно и то же приложение на нескольких машинах, нужно будет повторять одни и те же действия. Контейнеры избавляют от этой рутинной работы и позволяют автоматизировать развертывание.

### Контейнеры приближают к микросервисной архитектуре

Контейнеры хорошо вписываются в микросервисную архитектуру. Это подход к разработке, при котором приложение разбивается на небольшие компоненты, по возможности независимые. Обычно противопоставляется монолитной архитектуре, где все части системы сильно связаны друг с другом.

Это позволяет разрабатывать новую функциональность быстрее, ведь в случае с монолитной архитектурой изменение какой-то части может затронуть всю остальную систему.

### Docker compose — одновременно развернуть несколько контейнеров

Docker-compose позволяет разворачивать и настраивать несколько контейнеров одновременно. Например, для веб-приложения нужно развернуть стек LAMP: Linux + Apache, MySQL, PHP. Каждое из приложений — это отдельный контейнер для ОС Linux. Но в этой ситуации нам нужны именно все контейнеры вместе, а не отдельно взятое приложение. Docker-compose позволяет развернуть и настроить все приложения одной командой, а без него пришлось бы разворачивать и настраивать каждый контейнер отдельно.

## Хранение данных в Docker

Одна из главных особенностей контейнеров — эфемерность. Это означает, что контейнеры могут быть в любой момент остановлены, перезапущены или уничтожены. При этом все накопленные данные в контейнере будут потеряны. Поэтому приложения нужно разрабатывать так, чтобы они не полагались на хранилище данных в контейнере, это называется принципом Stateless.

Это хорошо подходит для приложений или сервисов, которые не сохраняют результаты своей работы. Например, функции расчета или преобразования данных: им на вход поступил один набор данных, они его преобразовали или рассчитали и вернули результат. Все, ничего никуда сохранять не нужно.

Но далеко не все приложения такие, и есть много данных, которые нужно сохранить. В контейнерах для этого предусмотрены несколько способов.

### Тома (Docker volumes)

Это способ, при котором Docker сам создает директории для хранения данных. Их можно сделать доступными для разных контейнеров, чтобы они могли обмениваться данными. По умолчанию эти директории создаются на хост-машине, но можно использовать и удаленные хранилища: файловый сервер или [объектное хранилище](https://slc.tl/I1MVZ).

### Монтирование каталога (bind mount)

В этом случае директория сначала создается на хост-машине а уже потом монтируется в контейнеры.

Но этот способ не рекомендуется, потому что он усложняет резервное копирование, миграцию и совместное использование данных несколькими контейнерами.

## Архитектура (компоненты) Docker

Теперь расскажем подробнее про компоненты, из которых состоит Docker.

### Docker daemon

Это некоторый резидентный процесс, который запущен на хост-машине постоянно. Он владеет всей инфраструктурой, а также предоставляет интерфейс взаимодействия с контейнерами, включающего создание и удаление, запуск и остановку.

В ранних версиях платформы Docker можно встретить упоминание о dockerd, но на текущий момент демоны уже успели разбиться на отдельные проекты. Все чаще можно встретить его современника — containerd. 

### Docker client (клиент)

Это интерфейс командной строки для управления Docker daemon. Мы пользуемся этим клиентом, когда создаем и разворачиваем контейнеры, а клиент отправляет эти запросы в Docker daemon.

### Docker image (образ)

Это неизменяемый файл (образ), из которого разворачиваются контейнеры. Приложения упаковываются именно в образы, из которых потом уже создаются контейнеры. В технической литературе можно также встретить описание image как шаблона запуска процесса.

Приведем аналогию на примере установки операционной системы. В дистрибутиве (образе) ОС есть все, что необходимо для ее установки. Но этот образ нельзя запустить, для начала его нужно «развернуть» в готовую ОС. Так вот, дистрибутив для установки ОС — это образ, а установленная и работающая ОС — это контейнер. Но контейнеры обычно разворачиваются одной командой — это намного проще и быстрее, чем установка ОС.

### Docker container (контейнер)

Это уже развернутое из образа и работающее приложение.

### Docker Registry

Это репозиторий с образами. Разработчики создают образы своих программ и выкладывают их в репозиторий, чтобы их можно было скачать и воспользоваться ими. Распространенный публичный репозиторий — [Docker Hub](https://hub.docker.com/). В нем собраны образы множества популярных программ или платформ: базы данных, веб-серверы, компиляторы, операционные системы и так далее. Также можно создать свой приватный репозиторий, например внутри компании. Разработчики будут размещать там образы, которые будут использоваться всей компанией.

### Dockerfile

Dockerfile — это инструкция для сборки образа. Это простой текстовый файл, содержащий по одной команде в каждой строке. В нем указываются все программы, зависимости и образы, которые нужны для разворачивания образа.

Для примера рассмотрим Dockerfile, который мы будем использовать далее в этой статье чтобы развернуть собственное приложение:

```
FROM python:3 
COPY main.py /
CMD [ "python", "./main.py" ]
```

Первая строчка означает, что за основу мы берем образ с названием python версии 3 это называется базовый образ. Docker найдет его в docker registry, скачает и будет использовать за основу. Вторая строчка означает, что нужно скопировать файл _main.py_ в корень файловой системы контейнера. Третья строчка означает, что нужно запустить python и передать ему в качестве параметра название файла _main.py_.

Далее рассмотрим примеры нескольких команд докер и что происходит, когда мы их выполняем.

![](https://selectel.ru/blog/wp-content/uploads/2021/04/docker-1525x690.png)

Все эти команды выполняются в Docker client, который отправляет их в Docker daemon:

- Команда **docker build** (зеленая стрелка) читает dockerfile и собирает образ.
- Команда **docker pull** (красная стрелка) скачивает образ из docker registry. По умолчанию docker скачивает образы из публичного репозитория Docker Hub. Но можно создать свой репозиторий и настроить докер, чтобы он работал с ним.
- Команда **docker run** (черная стрелка) берет образ и запускает из него контейнер.