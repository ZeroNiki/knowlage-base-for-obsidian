> `JSON Web Token (JWT)` — это _JSON_ объект, который определен в открытом стандарте [RFC 7519](https://tools.ietf.org/html/rfc7519). Он считается одним из безопасных способов передачи информации между двумя участниками. Для его создания необходимо определить заголовок (header) с общей информацией по токену, полезные данные (payload), такие как id пользователя, его роль и т.д. и подписи (signature).  

Простыми словами, _JWT_ — это лишь строка в следующем формате `header.payload.signature`.  
Предположим, что мы хотим зарегистрироваться на сайте. В нашем случае есть три участника — пользователь `user`, сервер приложения `application server` и сервер аутентификации `authentication server`. Сервер аутентификации будет обеспечивать пользователя токеном, с помощью которого он позднее сможет взаимодействовать с приложением.

  

![Как приложение использует JWT для проверки аутентификации пользователя.](https://habrastorage.org/r/w1560/getpro/habr/post_images/4e6/230/2d9/4e62302d99ae5382cfa1842a7d8e02da.png)

  

Приложение использует _JWT_ для проверки аутентификации пользователя следующим образом:

  

1. Сперва пользователь заходит на сервер аутентификации с помощью аутентификационного ключа (это может быть пара _логин/пароль_, либо _Facebook_ ключ, либо _Google_ ключ, либо ключ от другой учетки).
2. Затем сервер аутентификации создает _JWT_ и отправляет его пользователю.
3. Когда пользователь делает запрос к API приложения, он добавляет к нему полученный ранее _JWT_.
4. Когда пользователь делает API запрос, приложение может проверить по переданному с запросом _JWT_ является ли пользователь тем, за кого себя выдает. В этой схеме сервер приложения сконфигурирован так, что сможет проверить, является ли входящий _JWT_ именно тем, что был создан сервером аутентификации (процесс проверки будет объяснен позже более детально).

  

## Структура JWT

  

_JWT_ состоит из трех частей: заголовок `header`, полезные данные `payload` и подпись `signature`. Давайте пройдемся по каждой из них.

  

### Шаг 1. Создаем HEADER

  

Хедер _JWT_ содержит информацию о том, как должна вычисляться _JWT_ подпись. Хедер — это тоже _JSON_ объект, который выглядит следующим образом:

  

```
header = { "alg": "HS256", "typ": "JWT"}
```

  

Поле `typ` не говорит нам ничего нового, только то, что это _JSON Web Token_. Интереснее здесь будет поле `alg`, которое определяет алгоритм хеширования. Он будет использоваться при создании подписи. `HS256` — не что иное, как `HMAC-SHA256`, для его вычисления нужен лишь один секретный ключ (более подробно об этом в шаге 3). Еще может использоваться другой алгоритм `RS256` — в отличие от предыдущего, он является ассиметричным и создает два ключа: публичный и приватный. С помощью приватного ключа создается подпись, а с помощью публичного только лишь проверяется подлинность подписи, поэтому нам не нужно беспокоиться о его безопасности.

  

### Шаг 2. Создаем PAYLOAD

  

**Payload** — это полезные данные, которые хранятся внутри _JWT_. Эти данные также называют _JWT-claims_ (заявки). В примере, который рассматриваем мы, сервер аутентификации создает _JWT_ с информацией об _id_ пользователя — **userId**.

  

```
payload = { "userId": "b08f86af-35da-48f2-8fab-cef3904660bd" }
```

  

Мы положили только одну _заявку_ (claim) в _payload_. Вы можете положить столько _заявок_, сколько захотите. Существует список стандартных _заявок_ для _JWT_ payload — вот некоторые из них:

  

- _iss_ (issuer) — определяет приложение, из которого отправляется токен.
- _sub_ (subject) — определяет тему токена.
- _exp_ (expiration time) — время жизни токена.

  

Эти поля могут быть полезными при создании _JWT_, но они не являются обязательными. Если хотите знать весь список доступных полей для _JWT_, можете заглянуть в [Wiki](https://en.wikipedia.org/wiki/JSON_Web_Token#Standard_fields). Но стоит помнить, что чем больше передается информации, тем больший получится в итоге сам _JWT_. Обычно с этим не бывает проблем, но все-таки это может негативно сказаться на производительности и вызвать задержки во взаимодействии с сервером.

  

### Шаг 3. Создаем SIGNATURE

  

Подпись вычисляется с использование следующего псевдо-кода:

  

```
const SECRET_KEY = 'cAtwa1kkEy'
const unsignedToken = base64urlEncode(header) + '.' + base64urlEncode(payload)
const signature = HMAC-SHA256(unsignedToken, SECRET_KEY)
```

  

Алгоритм **base64url** кодирует хедер и payload, созданные на _1_ и _2_ шаге. Алгоритм соединяет закодированные строки через точку. Затем полученная строка хешируется алгоритмом, заданным в хедере на основе нашего секретного ключа.

  

```
// header eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
// payload eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ
// signature -xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```

  

### Шаг 4. Теперь объединим все три JWT компонента вместе

  

Теперь, когда у нас есть все три составляющих, мы можем создать наш _JWT_. Это довольно просто, мы соединяем все полученные элементы в строку через точку.

  

```
const token = encodeBase64Url(header) + '.' + encodeBase64Url(payload) + '.' + encodeBase64Url(signature)
// JWT Token
// eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```

  

Вы можете попробовать создать свой собственный _JWT_ на сайте [jwt.io](https://jwt.io/).  
Вернемся к нашему примеру. Теперь сервер аутентификации может слать пользователю _JWT_.

  

### Как JWT защищает наши данные?

  

Очень важно понимать, что использование _JWT_ **НЕ** скрывает и не маскирует данные автоматически. Причина, почему _JWT_ используются — это проверка, что отправленные данные были действительно отправлены авторизованным источником. Как было продемонстрировано выше, данные внутри _JWT_ закодированы и подписаны, обратите внимание, это не одно и тоже, что зашифрованы. Цель кодирования данных — преобразование структуры. Подписанные данные позволяют получателю данных проверить аутентификацию источника данных. Таким образом закодирование и подпись данных не защищает их. С другой стороны, главная цель шифрования — это защита данных от неавторизованного доступа. Для более детального объяснения различия между кодированием и шифрованием, а также о том, как работает хеширование, смотрите [эту статью](https://danielmiessler.com/study/encoding-encryption-hashing-obfuscation/#encoding). Поскольку _JWT_ только лишь закодирована и подписана, и поскольку _JWT_ не зашифрована, _JWT_ не гарантирует никакой безопасности для чувствительных _(sensitive)_ данных.

### Шаг 5. Проверка JWT

  

В нашем простом примере из 3 участников мы используем _JWT_, который подписан с помощью `HS256` алгоритма и только сервер аутентификации и сервер приложения знают секретный ключ. Сервер приложения получает секретный ключ от сервера аутентификации во время установки аутентификационных процессов. Поскольку приложение знает секретный ключ, когда пользователь делает API-запрос с приложенным к нему токеном, приложение может выполнить тот же алгоритм подписывания к _JWT_, что в шаге _3_. Приложение может потом проверить эту подпись, сравнивая ее со своей собственной, вычисленной хешированием. Если подписи совпадают, значит _JWT_ валидный, т.е. пришел от проверенного источника. Если подписи не совпадают, значит что-то пошло не так — возможно, это является признаком потенциальной атаки. Таким образом, проверяя _JWT_, приложение добавляет доверительный слой _(a layer of trust)_ между собой и пользователем.