- [[Бинарный поиск]] работает намного быстрее [[Простой поиск]].
- Время выполнения [[Логарифмическая сложность - O(log n)]] быстрее [[O(n) Линейная сложность]], а с увеличением размера спи­ска, в котором ищется значение, оно становится намного быстрее.
- Скорость алгоритмов не измеряется в секундах.
-  Время выполнения алгоритма описывается ростом количества операций.
-  Время выполнения алгоритмов выражается как [[BIG(O)]].

# Шпаргалка
- Память компьютера напоминает огромный шкаф с ящиками.

- Если вам потребуется сохранить набор элементов, воспользуйтесь мас­сивом или списком.[[Массив]]

- В массиве все элементы хранятся в памяти рядом друг с другом.

- В списке элементы распределяются в произвольных местах памяти, при этом в одном элементе хранится адрес следующего элемента.

-  Массивы обеспечивают быстрое чтение.

- Списки обеспечивают быструю вставку и выполнение. [[Связные списки]]

- Все элементы массива должны быть однотипными (только целые числа, только вещественные числа и т. д.).

# Шпаргалка
- Когда функция вызывает саму себя, это называется рекурсией.
- В каждой рекурсивной функции должно быть два случая: базовый и рекурсивный .
- Стек поддерживает две операции: зане­сение и извлечение элементов.
- Все вызовы функций сохраняются в сте­ке вызовов.
- Если стек вызовов станет очень большим, он займет слишком много памяти.
[[Стек]] [[Рекурсия]]

# Шпаргалка 
Шпаргалка
- Стратегия «разделяй и вла­ствуй» основана на разбиение задачи на уменьшающиеся фрагменты 

- Если вы реализуете алгоритм быстрой сортировки, выберите в качестве опорного случайный элемент. Среднее время выполнения быстрой сор­тировки составляет O(n log n)!

- Константы в «О-большом» иногда могут иметь значение . Именно по этой причине быстрая сортировка быстрее сортировки слиянием.

- При сравнении простой сортировки с бинарной константа почти никогда роли не играет, потому что O(log n) слишком сильно превосходит О(n) по скорости при большом размере списка.
[[BIG(O)]] || [[Разделяй и властвуй]] || [[Быстрая сотрировка]]

# Шпаргалка

Вам почти никогда не придется реализовать хеш-таблицу самостоятельно. Язык программирования, который вы используете, должен предоставить необходимую реализацию. Вы можете пользоваться хеш-таблицами Python, и при этом вам будет обеспечена производительность среднего случая: по­стоянное время.

Хеш-таблицы чрезвычайно полезны, потому что они обеспечивают высокую скорость операций и позволяют по-разному моделировать данные. Воз­можно, вскоре выяснится, что вы постоянно используете их в своей работе.

- Хеш-таблица создается объединением хеш-функции с массивом.

- Коллизии нежелательны. Хеш -функция должна свести количество кол­лизий к минимуму.

- Хеш-таблицы обеспечивают очень быстрое выполнение поиска, вставки и удаления.

- Хеш-таблицы хорошо подходят для моделирования отношений между объектами.

- Как только коэффициент заполнения превышает 0,7, пора изменять раз­мер хеш-таблицы.

- Хеш-таблицы используются для кэширования данных (например, на веб-серверах ).

- Хеш-таблицы хорошо подходят для обнаружения дубликатов.

# Шпаргалка
- [[Поиск в ширину]] вычисляет кратчайший путь в невзвешенном графе.
- [[Алгоритм Дийкстры]] вычисляет кратчайший путь во взвешенном графе.
- [[Алгоритм Дийкстры]] работает только в том случае, если все веса поло­жительны.
- При наличии отрицательных весов используйте алгоритм Беллмана­ Форда.
[[Граф]] || [[Алгоритм Дийкстры]]

# Шпаргалка
- Жадные алгоритмы стремятся к локальной оптимизации в расчете на то, что в итоге будет достигнут глобальный оптимум.
- У NР-полных задач не существует известных быстрых решений.
- Если у вас имеется NР-полная задача, лучше всего воспользоваться при­ ближенным алгоритмом.
- Жадные алгоритмы легко реализуются и быстро выполняются, поэтому из них получаются хорошие приближенные алгоритмы.
[[Оптимальные решения]] || [[Жадный алгоритм]] || [[задача о коммивояжере]]


# Шпаргалка
Надеюсь, вы хотя бы в общих чертах поняли, что можно сделать с помощью алгоритма k ближайших соседей и машинного обучения! Машинное обучение - интересная область, и при желании в нее можно зайти достаточно глубоко.

- Алгоритм k ближайших соседей применяется для классификации и ре­грессии. В нем используется проверка k ближайших соседей.
- Классификация = распределение по категориям.
- Регрессия= прогнозирование результата (например, в виде числа).
- «Извлечением признаков» называется преобразование элемента (на ­пример, фрукта или пользователя) в список чисел, которые могут ис­пользоваться для сравнения.