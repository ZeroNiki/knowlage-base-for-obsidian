# Kubernetes

**Kubernetes** — это мощный фреймворк для оркестрации контейнеров приложений, разработанный компанией Google. Как и docker swarm, он выполняет основные функции любого инструмента оркестрации: высокую доступность, защиту внутреннего трафика, инкапсуляцию сложной микросервисной архитектуры приложения в единую сущность и так далее. Но в чем основное отличие Kubernetes от **Docker Swarm**? Помимо более высокой сложности и большего количества доступных инструментов контроля контейнеров, основной особенностью Kubernetes является тот факт, что он является более высокоуровневым решением, чем Docker Swarm, и не завязан непосредственно на технологии *Docker*. Да, на данный момент Docker является абсолютным лидером в сфере контейнеризации приложений, но все же это не единственная технология, и Kubernetes предлагает единый подход вне зависимости от инструмента контейнеризации.

## Архитектура и принципы работы Kubernetes

Концептуально кластер Kubernetes представляет собой следующую структуру:

Архитектура Kubernetes включает в себя следующие основные компоненты:

![[k9s.png]]

**Master node** — это главный узел, который управляет всеми узлами в кластере Kubernetes. Он состоит из нескольких компонентов:

1. kube-apiserver — компонент, который предоставляет API для управления кластером Kubernetes.
2. etcd — хранилище ключ–значение, которое используется для хранения данных конфигурации кластера Kubernetes.
3. kube-scheduler — компонент, который отвечает за планирование работы на узлах в кластере Kubernetes.
4. kube-controller-manager — компонент, который управляет контроллерами, которые отвечают за выполнение операций, таких как масштабирование и восстановление после сбоев.

**Node** или **Worker node** — это узел, на котором работают контейнеры приложений. Он состоит из следующих компонентов:

1. kubelet — компонент, который управляет контейнерами на узле и взаимодействует с kube-apiserver на главном узле.
2. kube-proxy — компонент, который отвечает за маршрутизацию сетевых запросов к контейнерам на узле.

**Pod** — это наименьшая единица в Kubernetes, которая содержит один или несколько контейнеров приложения. Pod является минимальной абстракцией Kubernetes в силу того, что Kubernetes как технология стремится отойти от привязки к конкретному инструменту контейнеризации, поэтому и возникла необходимость в создании нового типа абстракции, являющегося дополнительным «контейнером для контейнера». Каждый Pod имеет свой IP-адрес (определяемый динамически в момент его запуска) и совместно использует ресурсы узла, на котором он работает. Важно понимать, что при перезапуске Pod, его IP-адрес изменяется, так как фактически поднимается новый Pod.

Но существует и множество других необходимых для понимания архитектуры Kubernetes объектов, большинство из которых представлены ниже:

**Service** — это объект Kubernetes, который обеспечивает постоянный IP-адрес и DNS-имя для доступа к приложению внутри кластера. Он может маршрутизировать запросы к разным Pod'ам на основе селекторов. Более того, при реплицировании Pod объект service выступает и в роли балансировщика, распределяющего запросы между репликами. 

**Volume** — это объект Kubernetes, который используется для хранения данных, которые нужны контейнерам в Pod. Volume может быть подключен к контейнеру приложения, чтобы обеспечить доступ к данным.

**Namespace** — это объект Kubernetes, который используется для группировки ресурсов кластера и разделения доступа к этим ресурсам между пользователями и командами.

В Kubernetes **реплицирование (replication)** — это механизм, который позволяет создавать несколько копий одного и того же приложения и запускать их на нескольких узлах. Это обеспечивает высокую доступность приложения, а также позволяет обрабатывать большую нагрузку.

**Реплика-контроллер (Replication Controller)** управляет процессом создания и масштабирования реплицированных подов (replicated pods) в Kubernetes. Когда создается реплика-контроллер, он создает необходимое количество подов, указанное в спецификации контроллера. Если какой-либо под выходит из строя или удаляется, контроллер автоматически создает новый под, чтобы заменить потерянный.

Реплицированные поды имеют **метку** (label), которая помогает реплика-контроллеру управлять ими. Метки также используются для того, чтобы сервисы (services) могли определять, какие поды должны принимать трафик.

Реплика-контроллеры могут быть использованы для масштабирования приложений горизонтально, путем увеличения или уменьшения количества реплицированных подов. Это позволяет быстро реагировать на изменения в нагрузке на приложение.

В Kubernetes **Deployment** и **StatefulSet** — это объекты, которые управляют запуском и масштабированием приложений. Оба объекта представляют собой декларативный способ определения желаемого состояния приложения и автоматического управления его жизненным циклом.

**Deployment** обеспечивает управление развертыванием (установкой) приложения в Kubernetes. Он описывает, как и когда необходимо создавать экземпляры приложения, а также какие обновления необходимо производить при изменении конфигурации. Deployment автоматически создает и управляет несколькими репликами приложения, что обеспечивает отказоустойчивость и масштабируемость.

**StatefulSet** обеспечивает управление установкой и масштабированием приложений, которые имеют состояние. Это может быть полезно, например, для баз данных, которые хранят данные на жестких дисках, и которые не могут быть просто скопированы и запущены на другом узле кластера. StatefulSet обеспечивает уникальные имена для каждого экземпляра приложения, сохраняет их состояние и предоставляет уникальные идентификаторы хостов для каждого экземпляра.

В обоих случаях Kubernetes автоматически управляет жизненным циклом приложения, масштабированием, обновлением и откатом изменений. Разработчики могут определить желаемое состояние приложения, а Kubernetes обеспечит, чтобы оно было достигнуто и поддерживалось в течение всего жизненного цикла приложения.

**Ingress** в Kubernetes — это объект, который позволяет управлять входящим трафиком в кластер. Ingress служит как контроллер, который определяет правила маршрутизации трафика между службами в кластере и внешним миром. Это позволяет разработчикам и администраторам управлять входящим трафиком, настраивать маршрутизацию и безопасность, а также осуществлять балансировку нагрузки. Кроме того, Ingress может использоваться для настройки SSL-шифрования и аутентификации клиентов. В целом, использование Ingress упрощает управление сетью и обеспечивает более гибкую и эффективную работу приложений в Kubernetes.

**ConfigMap** и **Secret** — это два механизма в Kubernetes для хранения конфигурационных данных и секретов, соответственно.

**ConfigMap** используется для хранения конфигурационных данных, которые используются приложениями в контейнерах (обычно в виде переменных окружения). Например, это могут быть параметры, которые должны быть изменены при развертывании приложения, такие как адрес базы данных или порт веб-сервера. ConfigMap может быть применен к любому количеству контейнеров в поде.

**Secret** используется для хранения конфиденциальной информации, такой как пароли, ключи и сертификаты. Secret может быть использован для любого количества контейнеров в поде. Важно отметить, что Secret хранится в зашифрованном виде в etcd кластера Kubernetes.

Использование ConfigMap и Secret позволяет снизить количество необходимых параметров в манифестах приложений и улучшить безопасность приложений, так как конфиденциальная информация не будет храниться в открытом виде.

## Интерфейс командной строки kubectl

**Kubectl** — это клиент Kubernetes API, предоставляющий доступ к функциям окружения Kubernetes. Kubernetes API представляет собой HTTP REST API сервер, предоставляющий доступ ко всем функциям Kubernetes как к эндпоинтам для HTTP-запросов.

### Основные команды kubectl

* **config**

Настройка и отображение конфигурации системы (kubeconfig):

  `kubectl config view`.

* **apply**

Управление ресурсами Kubernetes:

  `kubectl apply -f <относительный путь к манифесту>`;

  `kubectl explain pods`.

* **get**

Просмотр и поиск ресурсов системы:

  `kubectl get <название ресурса> --<параметры поиска>`.

* **edit, scale, delete**

Редактирование конкретных ресурсов системы. Наиболее популярные команды при сопровождении системы Kubernetes:

  `kubectl edit <название сервиса>`;

  `kubectl scale --replicas=<количество сервисов> <название сервиса|путь к файлу манифеста>`;

  `kubectl delete <название сервиса|путь к файлу манифеста>`.

* **logs**

Важный инструмент при отладке системы в случае возникновения ошибок. Зачастую проблема заключается не только в некорректной настройки системы оркестрации, но и в самом программном продукте, запущенном в окружении.

Для отладки программного продукта можно использовать команду:

  `kubectl logs <название сервиса>`.

## Манифест

**Манифест** в Kubernetes — это файл, который описывает желаемое состояние объекта Kubernetes. Манифест может содержать множество параметров и конфигурационных параметров для объекта, например, деплоймента, сервиса, конфигурационной карты и т. д.

Общая структура манифеста в Kubernetes:

```yml
apiVersion: <API версия> # версия API Kubernetes, которую использует объект
kind: <Тип объекта> # тип объекта (deployment, service, configmap и т. д.)
metadata: # метаданные объекта, такие как название, метки и т. д.
  name: <Название объекта>
  labels:
    <Метки объекта>
spec: # спецификация объекта, описывающая желаемое состояние
  <Параметры объекта>
```

Например, манифест для деплоймента может выглядеть следующим образом:


```yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-deployment
  labels:
    app: my-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-container
        image: my-image
        ports:
        - containerPort: 8080
```

В этом примере мы указываем желаемое количество реплик (3), определяем селектор для выбора подов (по метке `app: my-app`) и описываем шаблон пода, который будет создан в случае необходимости. В шаблоне мы указываем название контейнера, используемый образ и порт, который будет открыт в контейнере.

Часто применяется практика разделения манифестов на различные файлы, демонстрирующее поэтапное развертывание. Например, сначала можно создать конфиграционную карту, потом секреты, а потом сервисы и т. д.