## Это
K8S (аля kubernetes) - способ аркестрации контейнеров. Кароче говоря он нужен для автоматизации котнейнеров распределение нагрузки на конотейнеры и т.д

### Как работает
Kubernetes **позволяет определить желаемое состояние вашего приложения в виде кода (YAML-файлов), а затем автоматически создает и запускает контейнеры на основе этих определений**. Кроме того, платформа следит за сбоями и автоматически восстанавливает контейнеры и узлы.

### **Архитектура Kubernetes**

Архитектура Kubernetes (K8s) разработана с учетом сложных требований по управлению контейнерами и микросервисами. Она строится на модульности, расширяемости и горизонтальной масштабируемости. Рассмотрим основные компоненты архитектуры Kubernetes.

![[Pasted image 20240726132232.png]]

![[Pasted image 20240729122035.png]]

#### **Поды (Pods)**

Pods — **это наименьшие развертываемые вычислительные единицы**. Помимо контейнеров приложений, под может содержать контейнеры инициализации, которые запускаются во время запуска пода.

#### **Мастер-узел**

**Главный контролирующий компонент кластера называется** Master Node (мастер-узел). Он отвечает за принятие решений о состоянии кластера, с него выполняется планирование и распределение заданий, а также происходит управление ресурсами.

Для работы с объектами Kubernetes (подами, службами, репликациями и пр.) — их создания, изменения или удаления — необходимо взаимодействие с Kubernetes API. Его можно выполнить различными способами:

- **Посредством утилиты командной строки** _kubectl_. Утилита командной строки kubectl предоставляет удобный способ взаимодействия с Kubernetes API. Вы можете создавать, изменять и удалять объекты, а также получать информацию о состоянии кластера, используя команды _kubectl_.
- **Программно.** Вы можете использовать клиентские библиотеки, предоставляемые Kubernetes, чтобы взаимодействовать с API через программный код. Эти библиотеки предоставляют удобные методы для создания, чтения, обновления и удаления объектов Kubernetes.
- **Напрямую.** Помимо использования клиентских библиотек, вы также можете взаимодействовать с Kubernetes API напрямую, отправляя HTTP-запросы на соответствующие конечные точки API. Это может актуально, когда необходимо реализовать более специфичное поведение или управление.

Kubernetes API предоставляет RESTful-интерфейс, который позволяет взаимодействовать с объектами через HTTP-запросы. Для некоторых языков программирования существуют официальные клиентские библиотеки, которые упрощают работу с API, а также предоставляют средства для авторизации и аутентификации.

Для хранения всей конфигурации и состояния кластера используется эталонное хранилище (etcd), которое обеспечивает надежность и согласованность данных. За размещение подов (контейнеров) на физические или виртуальные узлы, учитывая требования ресурсов, ограничения и аффинитеты, отвечает Планировщик (Scheduler).

Аффинитеты могут быть двух типов:

- _node affinity_ (аффинитеты узла);
- _pod affinity_ (аффинитеты пода).

Аффинитеты позволяют вам управлять распределением подов в кластере с учетом требований к ресурсам, близости к другим подам или факторам.

#### **Узлы (Node)**

**Рабочие машины в кластере, на которых запускаются контейнеры, называются** Nodes (узлами). Nodes выполняют фактические задачи, они запускают и управляют контейнерами, а также передают состояние обратно на мастер-узел.

Каждый узел в кластере должен иметь установленный контейнерный движок _(Container Runtime)_. Когда вы запускаете под в Kubernetes, он создает и управляет контейнерами, используя контейнерный движок на конкретном узле. Вот примеры популярных контейнерных движков, которые могут использоваться в Kubernetes:

- **Docker** — один из самых популярных и используемых контейнерных движков. Он обеспечивает среду для запуска контейнеров и управление ими.
- [**containerd**](https://containerd.io/) — более низкоуровневый контейнерный движок, который был изначально разработан как часть проекта Docker. Он обеспечивает базовые функции для запуска и управления контейнерами.
- **CRI-O** — отдельный контейнерный движок, высокопроизводительный и легковесный, оптимизированный под минимальные требования при работе с контейнерами. Рассчитан на стандарты Container Runtime Interface (CRI).

Также на каждом узле есть агент **kubelet**. Это своего рода «сторож», который поддерживает связь между мастер-узлом и узлами, следит за запуском подов и обеспечивает их состояние.

В паре с агентом и контейнерным движком работает компонент **kubeproxy**, который обеспечивает взаимодействие между подами и внешними сетями, управляет сетевым проксированием и балансировкой нагрузки. Также он позволяет подам использовать стабильные DNS-имена для обращения друг к другу, даже если их IP-адреса изменяются.

#### **Services**

Service — метод предоставления доступа к сетевому приложению, работающему как один или несколько подов. Иначе говоря, это **способ сделать контейнеры (поды) доступными для других приложений**.

Когда у вас есть несколько контейнеров, работающих в вашем кластере, каждый из них может иметь свой IP-адрес и имя, которое не всегда стабильно, поскольку контейнеры могут перезапускаться или масштабироваться. Службы решают эту проблему, предоставляя стабильные имена и адреса для группы контейнеров.

Когда вы создаете службу, Kubernetes назначает ей уникальное имя и виртуальный IP-адрес. Этот виртуальный адрес будет использоваться, чтобы обращаться к службе, вместо того чтобы знать конкретные IP-адреса контейнеров.

Службы также автоматически маршрутизируют запросы к контейнерам (даже если они меняют свои IP-адреса или перезапускаются). Поэтому вам не нужно беспокоиться о точных IP-адресах контейнеров, вы можете обращаться к службам по их именам.

#### **Контроллеры**

В Kubernetes имеются **компоненты, отвечающие за поддержание желаемого состояния объектов в кластере,** — контроллеры. Они обеспечивают автоматическое масштабирование, управление отказоустойчивостью и обеспечивают поддержание правильного числа экземпляров приложений и сервисов в соответствии с заданными параметрами. Вот некоторые из них:

- **ReplicaSet** — один из базовых типов контроллеров. Он обеспечивает желаемое количество экземпляров подов (подов с одинаковым образом) в кластере. Если число подов снижается или увеличивается, ReplicaSet автоматически корректирует количество, чтобы оно соответствовало заданному.
- **Deployment** отвечает за управление репликами подов. Проще говоря, это абстракция поверх ReplicaSet, которая позволяет вам управлять обновлениями приложений. Он гарантирует возможность плавного обновления версии приложения, а также плавного отката к предыдущим версиям в случае проблем.
- **StatefulSet** — это контроллер для управления подами с уникальными идентификаторами и стабильными сетевыми именами.
- **DaemonSet** гарантирует, что на каждом узле в кластере будет работать по одному экземпляру пода. Он часто используется для приложений, которые должны быть запущены на каждом узле, например, сетевые плагины или мониторинговые агенты.
- **Job и CronJob**. Job обеспечивает выполнение определенной задачи (пода) и завершает его успешно. Когда задача успешно завершается, Job считается выполненным. Если задача завершается с ошибкой, Kubernetes может автоматически перезапустить ее для обеспечения успешного выполнения. CronJob — это планировщик, позволяющий запускать задачи (поды) периодически, подобно планировщику задач в операционных системах.

Эти и другие расширения обогащают функциональность Kubernetes и предоставляют средства для более эффективного управления контейнерами в разных сценариях, в зависимости от поставленных задач и требований.

## Основные концепты которые помогут в изучении

### Контейнеризация (как Docker)
*K8s - это среда где можно автоматизировать развёртывания и маштабирование контейнеров*

### Основы облачных вычисленний
Большинство облачных провайдеров используют  k8s

### YAML 
k8sfile пишется на языке yaml

### Основы работы в сети
Мне сюда в папку в `Сети`

### Linux
Я это знаю


