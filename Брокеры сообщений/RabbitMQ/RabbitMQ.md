**RabbitMQ** — это брокер сообщений (message broker) с открытым исходным кодом, написанный на Erlang. Он реализует классическую модель очередей сообщений, в основе которой протокол AMQP (Advanced Message Queuing Protocol).

Его используют для организации взаимодействия между приложениями:
- передача задач от одного сервиса другому,
- асинхронная обработка,
- балансировка нагрузки.

## Основные компоненты RabbitMQ
- **Producer (отправитель сообщений)**  
    Отправляет сообщение в брокер, указывая **exchange**.
- **Exchange (обменник)**  
    Принимает сообщение и решает, в какую очередь его направить.
    - _Direct exchange_ — маршрутизация по ключу.
    - _Fanout exchange_ — широковещательная отправка всем очередям.
    - _Topic exchange_ — маршрутизация по шаблонам (например, `logs.*`).
    - _Headers exchange_ — маршрутизация по заголовкам.
- **Queue (очередь)**
    Хранит сообщения до тех пор, пока их не прочитает потребитель.
- **Consumer (получатель)**
    Извлекает сообщения из очереди и обрабатывает их.
	
## Как работает RabbitMQ (в общих чертах)
1. Продюсер отправляет сообщение в **exchange**.
2. Exchange применяет правила маршрутизации и кладёт сообщение в одну или несколько **очередей**.
3. Консьюмер получает сообщение из очереди (обычно одно сообщение обрабатывается только одним консьюмером).


## Отличительные особенности
- RabbitMQ больше подходит для **традиционной очереди задач**.
- Поддерживает подтверждения доставки, повторные попытки, приоритеты сообщений.
- Подходит для случаев, где важна **гибкая маршрутизация** и гарантированная доставка.
- Но при очень больших потоках данных Kafka масштабируется лучше.

