## Этап 1. Понять задание, а не писать код

Не начинай с кода — сначала разберись в логике и сущностях.

Вопросы для себя:

* Кто участвует в процессе? (студент, экзаменатор, система, вопросы)
* Что каждый из них делает?
* Как они взаимодействуют между собой?
* Какие данные нужно хранить и передавать?

Пример сущностей:

* Студент — сдаёт экзамен, отвечает на вопросы, имеет статус.
* Экзаменатор — принимает студентов, может быть в разном настроении.
* Вопрос — имеет текст, по нему выбираются ответы.
* Система — управляет очередью, временем, отображением и сбором результатов.

---

## Этап 2. Разделение на сущности (классы)

Каждая «роль» из ТЗ становится классом.

Пример:

* Student: поля — name, gender, status, passed; методы — answer_question(question)
* Examiner: поля — name, total_students, failed, work_time, current_student; методы — examine(student), run()
* QuestionBank: поля — questions, stats; методы — get_random(), update_stats()
* ExamManager (или main/exam.py): отвечает за очередь, запуск процессов, отображение

Каждый класс отвечает только за свою часть поведения.

---

## Этап 3. Продумай поток данных (алгоритм)

Опиши в общих шагах, что происходит:

1. Система загружает списки студентов, экзаменаторов и вопросов.
2. Формируется очередь студентов.
3. Каждый экзаменатор начинает принимать студентов (в отдельных процессах или потоках).
4. Когда студент завершил экзамен — результат возвращается в общую очередь результатов.
5. Главный процесс:

   * обновляет статусы студентов,
   * обновляет статистику экзаменаторов,
   * выводит текущее состояние в консоль.
6. После завершения всех экзаменаторов собираются итоги, считается статистика и выводятся финальные таблицы.

Это «скелет» программы — последовательность шагов без деталей.

---

## Этап 4. Продумай механику внутри классов

Для каждого класса ответь на вопросы:

* Какие поля (состояния) у него должны быть?
* Какие методы он должен предоставлять?
* Какие побочные эффекты он может иметь (например, запись в очередь результатов)?

Примеры:

* Student:

  * поля: name, gender, status, start_time, end_time, passed
  * методы: answer_question(question) — выбирает слово по распределению (золотое сечение)
* Examiner:

  * поля: name, total_students, failed, current_student, start_time, work_time
  * методы: run() — главный цикл процесса; examine(student) — логика 3 вопросов, настроение, решение
* QuestionBank:

  * поля: questions, stats
  * методы: get_random(), update_stats(question, success)

---

## Этап 5. Работа с временем и состоянием

Определи, что выполняется синхронно, а что — параллельно:

* Если действие «ждёт» (таймер, sleep) или должно выполняться независимо — вынеси в отдельный поток или процесс.
* Если действие быстрое и локальное — можно выполнить синхронно в главном процессе.

В твоём ТЗ примеры:

* Экзаменатор уходит на обед через 30 секунд — это таймер, лучше в процессе экзаменатора.
* Время экзамена зависит от длины имени — модель в методе examine().

---

## Этап 6. Продумай вывод и интерактив

Определи модель состояния, которую будешь отображать в реальном времени:

* Таблица студентов: имя, статус (очередь / сдал / провалил)
* Таблица экзаменаторов: имя, текущий студент (или "-"), всего студентов, завалил, время работы
* Низ экрана: оставшиеся в очереди, прошедшее время

Выбери инструмент отображения:

* rich.Live для динамической консоли,
* или периодическое очищение экрана + prettytable для статичных снапшотов.

Важно: главный процесс собирает результаты из result_queue и обновляет объекты в своей памяти; именно эти объекты и отображаются.

---

## Этап 7. Подумай финальную статистику

Определи, какие метрики нужны и откуда брать данные:

* Процент сдавших: из списка студентов (s.passed)
* Лучшие студенты: минимальное (end_time - start_time) среди сдавших
* Лучшие экзаменаторы: минимальный процент провалов (failed / total_students)
* Студенты на отчисление: провалившие, завершившие раньше других проваливших
* Лучшие вопросы: вопросы с наибольшим количеством успешных ответов (QuestionBank.stats)

---

## Этап 8. Переход к коду

Когда есть:

* сущности (классы),
* алгоритм (пошаговая последовательность),
* структура данных (очереди, result_queue, объекты),

пиши код по модулям:

1. models/student.py
2. models/examiner.py
3. models/question_bank.py
4. utils/file_loader.py, utils/tables.py, utils/report.py
5. main.py (или exam.py) — orchestrator, Live/console loop, сбор результатов

Пиши и тестируй по одному модулю за раз: сначала загрузку данных и создание объектов, затем простую (однопроцессную) имитацию, потом заменяй на multiprocessing и добавляй отображение.

---

## Резюме: последовательность действий

1. Прочитать ТЗ и выделить действующих лиц.
2. Разбить задачу на классы.
3. Описать шаги (алгоритм взаимодействия).
4. Определить методы и данные для каждого класса.
5. Спроектировать обмен данными (очереди, форматы сообщений).
6. Спроектировать отображение состояния.
7. Написать код по модулям и тестировать по частям.
8. Собрать финальный отчёт и проверить корректность метрик.